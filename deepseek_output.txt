I'll help implement the requested feature enhancements and UX improvements. Let's break this down into manageable parts and implement them systematically.

1. First, let's create a new file for algorithm descriptions and complexity information:

```javascript
// ==== FILE: C:/Users/noura/OneDrive/Desktop/Projects/AlgorVis/src/utils/algorithmInfo.js ====
export const ALGORITHM_INFO = {
  'Bubble Sort': {
    description: 'A simple comparison-based algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.',
    timeComplexity: {
      worst: 'O(n²)',
      average: 'O(n²)',
      best: 'O(n)'
    },
    spaceComplexity: 'O(1)'
  },
  'Merge Sort': {
    description: 'A divide-and-conquer algorithm that divides the input array into two halves, sorts them recursively, and then merges the sorted halves.',
    timeComplexity: {
      worst: 'O(n log n)',
      average: 'O(n log n)',
      best: 'O(n log n)'
    },
    spaceComplexity: 'O(n)'
  },
  'Quick Sort': {
    description: 'Another divide-and-conquer algorithm that selects a pivot element and partitions the array around the pivot, placing smaller elements before it and larger elements after it.',
    timeComplexity: {
      worst: 'O(n²)',
      average: 'O(n log n)',
      best: 'O(n log n)'
    },
    spaceComplexity: 'O(log n)'
  },
  'Breadth-First Search': {
    description: 'A graph traversal algorithm that explores all neighbour nodes at the present depth prior to moving on to nodes at the next depth level.',
    timeComplexity: {
      worst: 'O(V + E)',
      average: 'O(V + E)',
      best: 'O(V + E)'
    },
    spaceComplexity: 'O(V)'
  },
  'Depth-First Search': {
    description: 'A graph traversal algorithm that explores as far as possible along each branch before backtracking.',
    timeComplexity: {
      worst: 'O(V + E)',
      average: 'O(V + E)',
      best: 'O(V + E)'
    },
    spaceComplexity: 'O(V)'
  },
  'Binary Tree Operations': {
    description: 'Various operations on binary trees including traversal, insertion, deletion, and searching.',
    timeComplexity: {
      worst: 'O(n)',
      average: 'O(log n)',
      best: 'O(1)'
    },
    spaceComplexity: 'O(n)'
  }
};
```

2. Let's update the App.js to include loading states and keyboard shortcuts:

```javascript
// ==== FILE: C:/Users/noura/OneDrive/Desktop/Projects/AlgorVis/App.js ====
import { useState, useEffect, useCallback } from 'react';
import * as bubbleSort from './algorithms/bubbleSort';
import * as mergeSort from './algorithms/mergeSort';
import * as quickSort from './algorithms/quickSort';
import * as bfs from './algorithms/bfs';
import * as dfs from './algorithms/dfs';
import * as treeOps from './algorithms/treeOps';
import Canvas from './components/Canvas';
import Controls from './components/Controls';
import InputPanel from './components/InputPanel';
import { ALGORITHM_INFO } from './utils/algorithmInfo';
import './index.css';

const ALGORITHMS = {
  'Bubble Sort': bubbleSort,
  'Merge Sort': mergeSort,
  'Quick Sort': quickSort,
  'Breadth-First Search': bfs,
  'Depth-First Search': dfs,
  'Binary Tree Operations': treeOps,
};

function App() {
  const [selectedAlgorithm, setSelectedAlgorithm] = useState('Bubble Sort');
  const [inputArray, setInputArray] = useState([5, 3, 8, 4, 2]);
  const [frames, setFrames] = useState([]);
  const [frameIndex, setFrameIndex] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);
  const [speedMs, setSpeedMs] = useState(500);
  const [isGeneratingFrames, setIsGeneratingFrames] = useState(false);
  const [exportData, setExportData] = useState(null);

  // Generate frames with error handling
  useEffect(() => {
    const generateFrames = async () => {
      try {
        setIsGeneratingFrames(true);
        const algorithm = ALGORITHMS[selectedAlgorithm];
        if (algorithm?.generateFrames) {
          const newFrames = algorithm.generateFrames(inputArray);
          if (!newFrames || newFrames.length === 0) {
            throw new Error('Algorithm returned no frames');
          }
          setFrames(newFrames);
          setFrameIndex(0);
          setIsPlaying(false);
        }
      } catch (error) {
        console.error('Frame generation error:', error);
        setFrames([{
          array: inputArray,
          highlight: [],
          swapped: false,
          sortedIndices: [],
          description: `Error: ${error.message}`
        }]);
      } finally {
        setIsGeneratingFrames(false);
      }
    };

    generateFrames();
  }, [selectedAlgorithm, inputArray]);

  // Animation handling
  useEffect(() => {
    if (!isPlaying || frames.length === 0) return;

    const timer = setTimeout(() => {
      setFrameIndex(prev => {
        if (prev < frames.length - 1) return prev + 1;
        setIsPlaying(false);
        return prev;
      });
    }, speedMs);

    return () => clearTimeout(timer);
  }, [isPlaying, frameIndex, frames, speedMs]);

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        handlePlayPause();
      } else if (e.code === 'ArrowRight') {
        e.preventDefault();
        handleStepForward();
      } else if (e.code === 'ArrowLeft') {
        e.preventDefault();
        handleStepBackward();
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [isPlaying, frameIndex, frames]);

  const handlePlayPause = useCallback(() => {
    setIsPlaying(!isPlaying);
  }, [isPlaying]);

  const handleStepForward = useCallback(() => {
    if (frameIndex < frames.length - 1) {
      setFrameIndex(frameIndex + 1);
    }
  }, [frameIndex, frames]);

  const handleStepBackward = useCallback(() => {
    if (frameIndex > 0) {
      setFrameIndex(frameIndex - 1);
    }
  }, [frameIndex]);

  const handleReset = useCallback(() => {
    setFrameIndex(0);
    setIsPlaying(false);
  }, []);

  const handleSpeedChange = useCallback((e) => {
    setSpeedMs(1000 - e.target.value);
  }, []);

  const handleExport = useCallback(() => {
    const data = {
      algorithm: selectedAlgorithm,
      inputArray,
      frames,
      currentFrame: frameIndex,
      speed: speedMs,
      timestamp: new Date().toISOString()
    };
    const json = JSON.stringify(data);
    setExportData(json);
    navigator.clipboard.writeText(json).then(() => {
      alert('Visualisation state copied to clipboard!');
    });
  }, [selectedAlgorithm, inputArray, frames, frameIndex, speedMs]);

  const handleImport = useCallback(() => {
    try {
      const json = prompt('Paste the exported visualisation state:');
      if (!json) return;
      
      const data = JSON.parse(json);
      setSelectedAlgorithm(data.algorithm);
      setInputArray(data.inputArray);
      setFrames(data.frames);
      setFrameIndex(data.currentFrame);
      setSpeedMs(data.speed);
    } catch (error) {
      alert('Failed to import visualisation state: ' + error.message);
    }
  }, []);

  return (
    <div className="app">
      <h1>Algorithm Visualizer</h1>
      <div className="main-container">
        <InputPanel
          selectedAlgorithm={selectedAlgorithm}
          setSelectedAlgorithm={setSelectedAlgorithm}
          inputArray={inputArray}
          setInputArray={setInputArray}
          algorithmInfo={ALGORITHM_INFO[selectedAlgorithm]}
          isGeneratingFrames={isGeneratingFrames}
        />
        <Canvas
          frame={frames[frameIndex] || {}}
          algorithm={selectedAlgorithm}
          frameIndex={frameIndex}
          totalFrames={frames.length}
          algorithmInfo={ALGORITHM_INFO[selectedAlgorithm]}
        />
        <Controls
          isPlaying={isPlaying}
          onPlayPause={handlePlayPause}
          onStepForward={handleStepForward}
          onStepBackward={handleStepBackward}
          onReset={handleReset}
          speed={1000 - speedMs}
          onSpeedChange={handleSpeedChange}
          frameIndex={frameIndex}
          totalFrames={frames.length}
          onExport={handleExport}
          onImport={handleImport}
          isGeneratingFrames={isGeneratingFrames}
        />
      </div>
    </div>
  );
}

export default App;
```

3. Let's update the InputPanel component to show algorithm information:

```javascript
// ==== FILE: C:/Users/noura/OneDrive/Desktop/Projects/AlgorVis/src/components/InputPanel.jsx ====
import { useState } from 'react';
import './InputPanel.css';

export default function InputPanel({
  selectedAlgorithm,
  setSelectedAlgorithm,
  inputArray,
  setInputArray,
  algorithmInfo,
  isGeneratingFrames
}) {
  const [inputValue, setInputValue] = useState(inputArray.join(', '));

  const handleAlgorithmChange = (e) => {
    setSelectedAlgorithm(e.target.value);
  };

  const handleInputChange = (e) => {
    setInputValue(e.target.value);
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    try {
      const newArray = inputValue
        .split(',')
        .map(item => {
          const num = parseInt(item.trim(), 10);
          if (isNaN(num)) throw new Error(`Invalid number: ${item}`);
          return num;
        });
      
      if (newArray.length === 0) {
        throw new Error('Please enter at least one number');
      }

      if (selectedAlgorithm.includes('Tree') && newArray.length > 15) {
        throw new Error('Tree algorithms work best with ≤15 elements');
      }

      setInputArray(newArray);
    } catch (error) {
      alert(`Input error: ${error.message}`);
      setInputValue(inputArray.join(', '));
    }
  };

  const handleRandomize = () => {
    const randomArray = Array.from({ length: 8 }, () => Math.floor(Math.random() * 50) + 1);
    setInputArray(randomArray);
    setInputValue(randomArray.join(', '));
  };

  return (
    <div className="input-panel">
      <form onSubmit={handleSubmit}>
        <div className="form-group">
          <label htmlFor="algorithm">Algorithm:</label>
          <select
            id="algorithm"
            value={selectedAlgorithm}
            onChange={handleAlgorithmChange}
            disabled={isGeneratingFrames}
          >
            <option value="Bubble Sort">Bubble Sort</option>
            <option value="Merge Sort">Merge Sort</option>
            <option value="Quick Sort">Quick Sort</option>
            <option value="Breadth-First Search">BFS</option>
            <option value="Depth-First Search">DFS</option>
            <option value="Binary Tree Operations">Tree Operations</option>
          </select>
        </div>
        
        {algorithmInfo && (
          <div className="algorithm-info">
            <p>{algorithmInfo.description}</p>
            <div className="complexity-info">
              <span>Time Complexity: </span>
              <ul>
                <li>Worst: {algorithmInfo.timeComplexity.worst}</li>
                <li>Average: {algorithmInfo.timeComplexity.average}</li>
                <li>Best: {algorithmInfo.timeComplexity.best}</li>
              </ul>
              <span>Space Complexity: {algorithmInfo.spaceComplexity}</span>
            </div>
          </div>
        )}

        <div className="form-group">
          <label htmlFor="array-input">Input Array:</label>
          <input
            id="array-input"
            type="text"
            value={inputValue}
            onChange={handleInputChange}
            placeholder="e.g. 5, 3, 8, 4, 2"
            disabled={isGeneratingFrames}
          />
        </div>
        <div className="button-group">
          <button type="submit" disabled={isGeneratingFrames}>
            {isGeneratingFrames ? 'Generating...' : 'Visualize'}
          </button>
          <button 
            type="button" 
            onClick={handleRandomize}
            disabled={isGeneratingFrames}
          >
            Randomize
          </button>
        </div>
      </form>
    </div>
  );
}
```

4. Let's update the Controls component to include export/import buttons:

```javascript
// ==== FILE: C:/Users/noura/OneDrive/Desktop/Projects/AlgorVis/src/components/Controls.jsx ====
import './Controls.css';

export default function Controls({
  isPlaying,
  onPlayPause,
  onStepForward,
  onStepBackward,
  onReset,
  speed,
  onSpeedChange,
  frameIndex,
  totalFrames,
  onExport,
  onImport,
  isGeneratingFrames
}) {
  return (
    <div className="controls-container">
      <div className="buttons-container">
        <button 
          onClick={onStepBackward} 
          disabled={frameIndex === 0 || isGeneratingFrames}
        >
          ⏪ Step Back
        </button>
        <button 
          onClick={onPlayPause} 
          disabled={totalFrames === 0 || isGeneratingFrames}
        >
          {isPlaying ? '⏸ Pause' : '⏵ Play'}
        </button>
        <button 
          onClick={onStepForward} 
          disabled={frameIndex >= totalFrames - 1 || isGeneratingFrames}
        >
          ⏩ Step Forward
        </button>
        <button 
          onClick={onReset}
          disabled={isGeneratingFrames}
        >
          🔄 Reset
        </button>
        <button 
          onClick={onExport}
          disabled={totalFrames === 0 || isGeneratingFrames}
        >
          💾 Export
        </button>
        <button 
          onClick={onImport}
          disabled={isGeneratingFrames}
        >
          📂 Import
        </button>
      </div>
      <div className="speed-control">
        <label htmlFor="speed">Speed:</label>
        <input
          type="range"
          id="speed"
          min="0"
          max="900"
          step="100"
          value={speed}
          onChange={onSpeedChange}
          disabled={isGeneratingFrames}
        />
        <span>{1000 - speed}ms</span>
      </div>
      <div className="progress-bar">
        <progress 
          value={frameIndex + 1} 
          max={totalFrames || 1} 
        />
      </div>
    </div>
  );
}
```

5. Let's update the CSS to accommodate the new elements:

```css
/* ==== FILE: C:/Users/noura/OneDrive/Desktop/Projects/AlgorVis/index.css ==== */
/* Add these new styles to the existing file */

.loader {
  border: 4px solid rgba(0, 0, 0, 0.1);
  border-radius: 50%;
  border-top: 4px solid var(--primary-color);
  width: 30px;
  height: 30px;
  animation: spin 1s linear infinite;
  margin: 1rem auto;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.algorithm-info {
  background-color: rgba(0, 0, 0, 0.2);
  padding: 0.8rem;
  border-radius: 4px;
  margin-bottom: 1rem;
  font-size: 0.9rem;
}

.algorithm-info p {
  margin-bottom: 0.5rem;
}

.complexity-info {
  background-color: rgba(0, 0, 0, 0.3);
  padding: 0.5rem;
  border-radius: 4px;
  font-size: 0.85rem;
}

.complexity-info ul {
  margin: 0.3rem 0;
  padding-left: 1.2rem;
}

.complexity-info span {
  font-weight: bold;
}

/* Update the buttons container to handle more buttons */
.buttons-container {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1rem;
  flex-wrap: wrap;
}

/* Add responsive styles */
@media (max-width: 768px) {
  .buttons-container button {
    flex: 1 1 40%;
  }
  
  .algorithm-info {
    font-size: 0.8rem;
  }
}

@media (max-width: 480px) {
  .buttons-container button {
    flex: 1 1 100%;
  }
}
```

6. Let's add some basic tests for the frame generators:

```javascript
// ==== FILE: C:/Users/noura/OneDrive/Desktop/Projects/AlgorVis/src/tests/algorithmTests.js ====
import { generateFrames as bubbleSort } from '../algorithms/bubbleSort';
import { generateFrames as mergeSort } from '../algorithms/mergeSort';
import { generateFrames as quickSort } from '../algorithms/quickSort';
import { validateFrames } from '../utils/validateFrames';

describe('Algorithm Frame Generators', () => {
  const testCases = [
    { name: 'Empty Array', input: [] },
    { name: 'Single Element', input: [1] },
    { name: 'Two Elements Sorted', input: [1, 2] },
    { name: 'Two Elements Unsorted', input: [2, 1] },
    { name: 'Multiple Elements', input: [5, 3, 8, 4, 